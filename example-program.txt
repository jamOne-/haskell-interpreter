data Tree = Empty | Leaf int | Node Tree int Tree;
data Bin = Zero | One;
data PairList = Pair int-list int-list;

let (f :: Tree) (x :: Tree) = (Leaf y)
    (y :: int) = 26 + 1 in
(f (Node (Leaf 42) 27 (Node (Leaf 42) 27 (Leaf 1))));

if 2 == 3 then Zero else One;

let (lst :: int-list) = [1+2, 4*5, 100 - 1] in ((head lst) : (tail lst));

let (take :: int-list) (lst :: int-list) (n :: int) =
  if n == 0
     then []
     else ((head lst) : (take (tail lst) (n - 1)))
in let (lst :: int-list) (n :: int) = (n : (lst (n + 1)))
in let (nats :: int-list) = (lst 0)
 in (take nats 50);


let
  (isPrime :: bool) (n :: int) =
                                let (aux :: bool) (i :: int) =
                                                              if n == i
                                                              then True
                                                              else if n `mod` i == 0
                                                                  then False
                                                                  else (aux (i + 1))
                                in (aux 2)

  (primes :: int-list) =
                        let (aux :: int-list) (i :: int) =
                                                          if isPrime i
                                                          then i:(aux (i + 1))
                                                          else (aux (i + 1))
                        in (aux 2)

  (list-ref :: int) (xs :: int-list) (i :: int) =
                                                  if i == 0
                                                  then head xs
                                                  else (list-ref (tail xs) (i - 1))

  (take :: int-list) (lst :: int-list) (n :: int) =
        if n == 0
           then []
           else ((head lst) : (take (tail lst) (n - 1)))

in (Pair (take primes 5) (take primes 5))
